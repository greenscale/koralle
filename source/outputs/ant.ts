
/**
 * @author fenris
 */
class class_target_ant extends class_target_regular<lib_ant.class_action> {
	
	/**
	 * @author fenris
	 */
	public constructor() {
		super("ant");
	}
		
	
	/**
	 * @override
	 * @author fenris
	 */
	public tempfolder() : string {
		switch (configuration.system) {
			case "linux": {
				return "/tmp/";
				break;
			}
			case "bsd": {
				return "/tmp/";
				break;
			}
			case "win": {
				return "${env.TEMP}\\";
				break;
			}
			default: {
				throw (new Error(`invalid system '${configuration.system}'`));
				break;
			}
		}
	}
	
			
	/**
	 * @author fenris
	 */
	public compile_task(task : class_task, path : Array<string> = []) : Array<lib_ant.class_target> {
		let path_ : Array<string> = /*path.concat(*/[task.name_get()]/*)*/;
		let targets_core : Array<lib_ant.class_target> = [
			new lib_ant.class_target(
				{
					"name": path_.join("-"),
					"dependencies": (
						task.sub_get()
						.filter(task_ => task_.active_get())
						.map(task_ => /*path_.concat(*/[task_.name_get()]/*)*/.join("-"))
					),
					"actions": (
						[]
						.concat([new class_action_echo(task.name_get())])
						.concat(task.actions())
						.map(action => this.compile_action(action))
					)
				}
			)
		];
		let targets_sub : Array<lib_ant.class_target> = task.sub_get()
			.map(task_ => this.compile_task(task_, path_))
			.reduce((x, y) => x.concat(y), [])
		;
		return [].concat(targets_core).concat(targets_sub);
	}
	
	
	/**
	 * @author fenris
	 */
	protected compile_project(project : class_project, without_dependencies : boolean = false) : lib_ant.class_project {
		let comments : Array<lib_ant.class_comment> = [
			`Project \"${project.name_get()}\"`,
			`This build script was generated by Koralle ${configuration.version}`,
		].map(x => new lib_ant.class_comment(x));
		// let dependencies : Array<class_task> = project.dependencytasks(this.identifier);
		let targets : Array<lib_ant.class_target> = []
			/*
			.concat(
				[
					new lib_ant.class_target(
						{
							"name": "__root",
							"dependencies": ["__dependencies", "__core"],
						}
					)
				]
			)
			.concat(
				[
					new lib_ant.class_target(
						{
							"name": "__dependencies",
							"dependencies": without_dependencies ? [] : dependencies.map(dependency => dependency.name_get()),
						}
					)
				]
			)
			.concat(
				dependencies.map(dependency => this.compile_task(dependency)).reduce((x, y) => x.concat(y), [])
			)
			.concat(
				[
					new lib_ant.class_target(
						{
							"name": "__core",
							"dependencies": [project.roottask_get().name_get()],
						}
					)
				]
			)
			 */
			.concat(
				this.compile_task(project.roottask_get())
			)
		;
		return (
			new lib_ant.class_project(
				{
					"name": project.name_get(),
					"default": "__root",
					"comments": comments,
					"targets": targets,
				}
			)
		);
	}
	
	
	/**
	 * @override
	 * @author fenris
	 */
	public compile_project_string(project : class_project) : string {
		return this.compile_project(project).compile().compile();
	}
	
	
	/**
	 * @override
	 * @author fenris
	 */
	public execute(filepointer : lib_path.class_filepointer, workdir : string = ".") : lib_call.type_executor<void, Error> {
		return (
			(resolve, reject) => {
				let command : string = [
					"ant",
					"-file " + filepointer.toString(),
				].join(" ");
				_child_process.exec(
					command,
					{},
					function (stdout : string, stderr : string, error : Error) : void {
						if (error == null) {
							resolve(undefined);
						}
						else {
							reject(error);
						}
					}
				)
			}
		);
	}
	
}

