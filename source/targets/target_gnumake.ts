
///<reference path="../../../plankton/call/build/logic.d.ts"/>


/**
 * @author fenris
 */
class class_target_gnumake extends class_target_regular<string> {
	
	/**
	 * @author fenris
	 */
	public constructor() {
		super("gnumake");
	}
	
	
	/**
	 * @author fenris
	 */
	protected compile_task(
		task : class_task,
		path : Array<string> = [],
		depth : int = 0,
		prefix : string = null
	) : Array<lib_gnumake.class_rule> {
		let path_ : Array<string> = /*path.concat(*/[task.name_get()]/*)*/;
		let logging_begin : class_action = new class_action_echo(
			(new class_message("processing '" + path_.join("-") + "' ...", {"type": "log", "depth": depth, "prefix": prefix})).generate()
		);
		let logging_end : class_action = new class_action_echo(
			(new class_message("... finished '" + path_.join("-") + "'", {"type": "log", "depth": depth, "prefix": prefix})).generate()
		);
		let rules_core : Array<lib_gnumake.class_rule> = [];
		{
			// meta rule
			rules_core.push(
				new lib_gnumake.class_rule(
					{
						"name": path_.join("-"),
						"dependencies": (
							[]
							.concat(
								["__logging_" + path_.join("-")]
							)
							.concat(
								task.sub_get()
								.filter(task_ => task_.active_get())
								.map(task_ => /*path_.concat(*/[task_.name_get()]/*)*/.join("-"))
							)
							.concat(
								task.outputs().map(filepointer => filepointer.toString())
							)
						),
						"actions": (
							[]
							.concat((task.outputs().length == 0) ? task.actions() : [])
							// .concat([logging_end])
							.map(action => this.compile_action(action))
						),
						"phony": true,
					}
				)
			);
			// logging
			rules_core.push(
				new lib_gnumake.class_rule(
					{
						"name": ("__logging_" + path_.join("-")),
						"actions": [logging_begin].map(action => this.compile_action(action)),
						"phony": true,
					}
				)
			);
			// actual rule
			if (task.outputs().length > 0) {
				rules_core.push(
					new lib_gnumake.class_rule(
						{
							"name": task.outputs().map(filepointer => filepointer.toString()).join(" "), // hacky!
							"dependencies": task.inputs().map(filepointer => filepointer.toString()),
							"actions": task.actions().map(action => this.compile_action(action)),
							"phony": false,
						}
					)
				);
			}
		}
		let rules_sub : Array<lib_gnumake.class_rule> = [];
		{
			rules_sub = task.sub_get()
				.map(task_ => this.compile_task(task_, path_, depth+1, prefix))
				.reduce((x, y) => x.concat(y), [])
			;
		}
		return ([].concat(rules_core).concat(rules_sub));
	}
	
	
	/**
	 * @author fenris
	 */
	protected compile_project(project : class_project, without_dependencies : boolean = false) : lib_gnumake.class_sheet {
		let that : class_target_gnumake = this;
		let comments : Array<string> = [
			"Project \"" + project.name_get() + "\"",
			"This makefile was generated by Koralle " + configuration["version"],
		];
		let dependencies : Array<class_task> = project.dependencies_get().map(
			function (path : string, index : int) : class_task_dependency {
				return (
					new class_task_dependency(
						"__dependency_" + index.toString(),
						[],
						true,
						lib_path.class_filepointer.read(path),
						that.identifier,
						true,
						undefined
					)
				);
			}
		);
		let rules : Array<lib_gnumake.class_rule> = []
			.concat(
				[
					new lib_gnumake.class_rule(
						{
							"name": "__default",
							"dependencies": ["__root"],
							"actions": [],
							"phony": true,
						}
					)
				]
			)
			.concat(
				[
					new lib_gnumake.class_rule(
						{
							"name": "__root",
							"dependencies": ["__dependencies", "__core"],
							"phony": true,
						}
					)
				]
			)
			.concat(
				[
					new lib_gnumake.class_rule(
						{
							"name": "__dependencies",
							"dependencies": without_dependencies ? [] : dependencies.map(dependency => dependency.name_get()),
							"phony": true,
						}
					)
				]
			)
			.concat(
				dependencies.map(dependency => this.compile_task(dependency)).reduce((x, y) => x.concat(y), [])
			)
			.concat(
				[
					new lib_gnumake.class_rule(
						{
							"name": "__core",
							"dependencies": [project.roottask_get().name_get()],
							"phony": true,
						}
					)
				]
			)
			.concat(
				this.compile_task(project.roottask_get(), undefined, undefined, project.name_get())
			)
		;
		return (new lib_gnumake.class_sheet(rules, comments));
	}
	
	
	/**
	 * @override
	 * @author fenris
	 */
	public compile_project_string(project : class_project, without_dependencies : boolean = false) : string {
		return (this.compile_project(project, without_dependencies).compile(true));
	}
	
	
	/**
	 * @override
	 * @author fenris
	 */
	public execute(filepointer : lib_path.class_filepointer) : lib_cdh_call.type_executor<void, Error> {
		return (
			(resolve, reject) => {
				let command : string = (
					  ["cd", filepointer.location].join(" ")
					+ " && "
					+ ["make", "--file=" + filepointer.filename].join(" ")
					+ " ; "
					+ ["cd", "-"].join(" ")
				);
// (new class_message(command, {"prefix": "exec:command"})).stderr();
				_child_process.exec(
					command,
					{},
					function (stdout : string, stderr : string, error : Error) : void {
						/*
						(new class_message(stdout, {"prefix": "exec:stdout"})).stderr();
						(new class_message(stderr, {"prefix": "exec:stderr"})).stderr();
						(new class_message(String(error), {"prefix": "exec:error"})).stderr();
						 */
						if (error == null) {
							resolve(undefined);
						}
						else {
							reject(error);
						}
					}
				)
			}
		);
	}
	
}

